"use strict";(self.webpackChunksiren=self.webpackChunksiren||[]).push([[899],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(r),m=i,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return r?n.createElement(f,o(o({ref:t},p),{},{components:r})):n.createElement(f,o({ref:t},p))}));function m(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},5272:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(3117),i=(r(7294),r(3905));const a={},o="CortexMetrics",s={unversionedId:"providers/cortexmetrics",id:"providers/cortexmetrics",title:"CortexMetrics",description:"|||",source:"@site/docs/providers/cortexmetrics.md",sourceDirName:"providers",slug:"/providers/cortexmetrics",permalink:"/siren/docs/providers/cortexmetrics",draft:!1,editUrl:"https://github.com/odpf/siren/edit/master/docs/docs/providers/cortexmetrics.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Job",permalink:"/siren/docs/guides/job"},next:{title:"Slack",permalink:"/siren/docs/receivers/slack"}},l={},c=[{value:"Multi-tenancy",id:"multi-tenancy",level:2},{value:"Server Configuration",id:"server-configuration",level:2}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cortexmetrics"},"CortexMetrics"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"type")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"cortex"))))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://cortexmetrics.io/"},"CortexMetrics")," is a Horizontally scalable, highly available, multi-tenant, long term storage for Prometheus. It could run in multi-tenant scenario where it isolates data and queries from multiple different independent Prometheus sources in a single cluster, allowing untrusted parties to share the same cluster."),(0,i.kt)("p",null,"Similar with how prometheus works, CortexMetrics consumes metrics sent from other services, store, and evaluate the metrics with the configured rules. Alerts will be triggered and processed by CortexMetrics' alert manager and notifications will be sent to the designated sinks (webhook, slack, pagerduty, etc..). "),(0,i.kt)("p",null,"Since Siren handles all subscriptions and notifications routing, Siren configures CortexMetrics to send all alerts only to Siren webhook API."),(0,i.kt)("h2",{id:"multi-tenancy"},"Multi-tenancy"),(0,i.kt)("p",null,"Tenants in CortexMetrics are mapped to ",(0,i.kt)("a",{parentName:"p",href:"/siren/docs/guides/provider_and_namespace#namespace"},"Namespaces")," in Siren. To integrate multiple tenants, you need to create multiple namespaces for each tenant. Each tenant will have different configuration."),(0,i.kt)("h2",{id:"server-configuration"},"Server Configuration"),(0,i.kt)("p",null,"There is a generic CortexMetrics configuration in Siren server configuration that could be used to tune the CortexMetrics. The configuration will always be synchronized everytime a namespace in Siren is created or updated."),(0,i.kt)("p",null,"Here is a config that is part of the server configuration. Please note that the config will always be applied to all CortexMetrics registered in Siren and only synchronized when a namespace in Siren is created or updated. Siren server restart is also required to get the latest value update of these configs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"...\nproviders:\n  cortex:\n    group_wait: 30s\n    webhook_base_api: http://localhost:8080/v1beta1/alerts/cortex\n...\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"group_wait")," config usage is similar with the one in CortexMetrics alert manager ",(0,i.kt)("a",{parentName:"li",href:"https://prometheus.io/docs/alerting/latest/configuration/#example"},"configuration"),"."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"webhook_base_api")," defined the base API that will be appended with ",(0,i.kt)("inlineCode",{parentName:"li"},"provider_id")," for each specific provider. If a namespace of provider with id ",(0,i.kt)("inlineCode",{parentName:"li"},"3")," is updated, Siren will configure the webhook receiver in CortexMetrics with this URL: ",(0,i.kt)("inlineCode",{parentName:"li"},"http://localhost:8080/v1beta1/alerts/cortex/3"),".")))}u.isMDXComponent=!0}}]);